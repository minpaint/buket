# Generated by Codex on 2026-02-18
from django.db import migrations


def forwards(apps, schema_editor):
    Product = apps.get_model('shop', 'Product')
    Store = apps.get_model('shop', 'Store')
    ProductImage = apps.get_model('shop', 'ProductImage')
    OrderItem = apps.get_model('shop', 'OrderItem')

    active_store_ids = list(Store.objects.filter(is_active=True).values_list('id', flat=True))

    # 1) Seed M2M from legacy FK store where present.
    for p in Product.objects.exclude(store_id=None).iterator():
        p.stores.add(p.store_id)

    # 2) Deduplicate by (article, title): keep minimal id and merge data.
    groups = {}
    for p in Product.objects.all().order_by('id').iterator():
        key = ((p.article or '').strip(), (p.title or '').strip())
        groups.setdefault(key, []).append(p.id)

    for _, ids in groups.items():
        if len(ids) <= 1:
            continue

        keep_id = ids[0]
        drop_ids = ids[1:]
        keeper = Product.objects.get(id=keep_id)
        duplicates = list(Product.objects.filter(id__in=drop_ids))

        # Merge categories and stores.
        cat_ids = set(keeper.categories.values_list('id', flat=True))
        store_ids = set(keeper.stores.values_list('id', flat=True))
        for d in duplicates:
            cat_ids.update(d.categories.values_list('id', flat=True))
            store_ids.update(d.stores.values_list('id', flat=True))
            if d.store_id:
                store_ids.add(d.store_id)

        if cat_ids:
            keeper.categories.set(cat_ids)
            if not keeper.category_id:
                keeper.category_id = sorted(cat_ids)[0]

        if store_ids:
            keeper.stores.set(store_ids)

        # Move order items to keeper before deleting duplicates.
        OrderItem.objects.filter(product_id__in=drop_ids).update(product_id=keep_id)

        # Merge product images (unique by file path).
        existing_image_paths = set(ProductImage.objects.filter(product_id=keep_id).values_list('image', flat=True))
        for d in duplicates:
            for img in ProductImage.objects.filter(product_id=d.id).order_by('sort_order', 'id'):
                if img.image in existing_image_paths:
                    continue
                ProductImage.objects.create(
                    product_id=keep_id,
                    image=img.image,
                    sort_order=img.sort_order,
                )
                existing_image_paths.add(img.image)

        # Keep legacy store null to avoid stale single-store semantics.
        keeper.store_id = None
        keeper.save(update_fields=['category', 'store'])

        Product.objects.filter(id__in=drop_ids).delete()

    # 3) Business rule: every bouquet is available in every active store.
    if active_store_ids:
        for p in Product.objects.all().iterator():
            p.stores.set(active_store_ids)
            if p.store_id is not None:
                p.store_id = None
                p.save(update_fields=['store'])


def backwards(apps, schema_editor):
    Product = apps.get_model('shop', 'Product')
    # Best-effort rollback: project first assigned store from M2M back to legacy FK.
    for p in Product.objects.all().iterator():
        first_store = p.stores.order_by('id').first()
        p.store_id = first_store.id if first_store else None
        p.save(update_fields=['store'])


class Migration(migrations.Migration):

    dependencies = [
        ('shop', '0012_product_stores_alter_product_store'),
    ]

    operations = [
        migrations.RunPython(forwards, backwards),
    ]
